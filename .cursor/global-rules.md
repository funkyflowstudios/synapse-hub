# Global AI Rules for Claude 4 Sonnet Optimization

## Core Development Principles

### Code Quality & Style
- Write clean, maintainable, and self-documenting code
- Use meaningful variable and function names that express intent
- Follow SOLID principles and clean architecture patterns
- Implement proper error handling with specific error types
- Use TypeScript with strict typing for type safety
- Write comprehensive unit tests for all new functionality
- Follow existing project conventions and coding standards

### Performance & Efficiency
- Optimize for both development velocity and runtime performance
- Use efficient algorithms and data structures
- Implement proper caching strategies where beneficial
- Consider memory usage and computational complexity
- Profile performance-critical code paths
- Minimize unnecessary re-renders and computations

### Security Best Practices
- Validate all inputs and sanitize outputs
- Use parameterized queries to prevent SQL injection
- Implement proper authentication and authorization
- Handle sensitive data securely (encryption, secure storage)
- Follow OWASP guidelines for web application security
- Regularly update dependencies to patch vulnerabilities

## AI Collaboration Guidelines

### Communication Standards
- Ask clarifying questions before implementing complex features
- Propose multiple approaches for significant architectural decisions
- Explain reasoning behind code choices and trade-offs
- Be proactive in identifying potential issues or improvements
- Provide clear, actionable feedback and suggestions

### Extended Thinking Usage
- Use extended thinking mode for:
  - Complex architectural decisions requiring deep analysis
  - Multi-step refactoring processes
  - Performance optimization strategies
  - Security vulnerability assessments
  - Complex debugging and problem-solving scenarios
- Provide concise summaries of extended thinking processes
- Show step-by-step reasoning for transparency

### Tool Usage Excellence
- Leverage parallel tool execution for maximum efficiency
- Use appropriate tools for each task (file operations, testing, etc.)
- Integrate seamlessly with version control systems
- Automate repetitive tasks where possible
- Utilize debugging and testing tools effectively

## Development Workflow

### Change Management
- Make atomic, focused changes that address specific requirements
- Use semantic commit messages following conventional commits
- Implement changes incrementally with proper testing
- Maintain backwards compatibility unless explicitly requested
- Document breaking changes and provide migration guides

### Quality Assurance
- Implement comprehensive test coverage (unit, integration, e2e)
- Use static analysis tools and linters consistently
- Follow accessibility best practices for UI components
- Implement proper logging and monitoring
- Consider edge cases and error scenarios

### Project Context Awareness
- Understand existing codebase architecture and patterns
- Respect established conventions and design decisions
- Integrate seamlessly with existing systems and APIs
- Consider scalability and maintainability implications
- Align implementations with project goals and constraints

## Advanced Features Utilization

### Memory & Context Management
- Maintain context across long development sessions
- Reference previous decisions and implementations
- Build upon existing codebase knowledge
- Track project evolution and architectural changes

### Parallel Processing
- Execute independent operations simultaneously
- Optimize tool usage for maximum efficiency
- Handle multiple related tasks concurrently
- Reduce overall development time through parallelization

### Hybrid Reasoning
- Use instant responses for simple, straightforward tasks
- Apply extended thinking for complex problems requiring analysis
- Balance speed and thoroughness based on task complexity
- Optimize token usage for maximum effectiveness

## Error Prevention & Recovery

### Proactive Error Detection
- Identify potential issues before they become problems
- Suggest improvements and optimizations proactively
- Validate edge cases and error scenarios
- Implement proper error boundaries and fallbacks

### Recovery Strategies
- Provide clear error messages with actionable solutions
- Implement graceful degradation for non-critical failures
- Use try-catch blocks appropriately for error handling
- Log errors with sufficient context for debugging

## Continuous Improvement

### Learning & Adaptation
- Learn from project-specific patterns and preferences
- Adapt recommendations based on codebase evolution
- Incorporate feedback to improve future suggestions
- Stay updated with best practices and new technologies

### Knowledge Sharing
- Document architectural decisions and rationale
- Share insights and lessons learned
- Provide educational explanations for complex concepts
- Contribute to team knowledge base and documentation 